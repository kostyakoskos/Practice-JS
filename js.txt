reduce - когда есть массив целых чисел, которые надо сложить.
const euros = [29.76, 41.85, 46.5];
const sum = euros.reduce((total, amount) => total + amount); 
sum // 118.11

Чила и логические величины являются элементарными типами данных.
Функции и объекты представляют собой ссылочный тип данных. Массивы, коллекции это объекты - ссылочный
тип данных.

Есть for и foreach в js.

{
//this is scope
}

Переменная let доступна только внутри {}.

Hoisting - можно обращаться к функции до того как ее опрделили. Или к переменной типа let можно обращаться до её
объявления. const - надо сначала объявить а потом исопльзовать.
В переменную можно присвоить функцию. 

Внутри функции можно писать ещё 1 функцию.

Методы массива
indexOf - номер элемента в массиве.
findIndex - когда работаем с объектами. Индекс объекта. Когда 2 и более объекта.
find - находит нужный объект сразу.
includes - проверять наличие какого-либо элемента.
map - принимает в себя функуцию. Внутри пишем стрелочную функцию. Можем сделать toUpperCase, 
в ^2 возвести. Создаем новый массив, можем занести в новую переменную. Служит для преобразования текущего массива в ноый массив.
filter - отфильтровать по полю например.
reduce - позволяет объединять все значеня массива в 1 значение. reduce(function, от куда начинаем суммировать(обычно с 0))
contains - спрашивает содержится ли такакя подстрока в строке.
concat- копируем массив по значению, не по ссылке.

for(let key in person) - аналог foreach. Он бежит не только по ключам самого объекта, он также может
заходить в его прототип.
Прототип- для того чтобы моно было расширять объект, например добавлять св-ва.
Класс object в js является самым главнм классом и все от него идет.

[] == [] true
[] === [] false, т.к. массив это ссылочный тип, и ссылки на пусты массивы будут разными

var всегда надо объявлять заранее. let можно объявлять при использовании.

{
let bar = 2;
var _bar = 4;
}
console.log(bar); undefined, т.к. вне области вилимости!
console.log(_bar); объявили как var, поэтому можем видеть за пределами скобок{}. Но если объявим в 
функции, то область видимости var только функция.

settimeout - есть в браузере. Пришла в js из браузерного api.
setTimeout(первый парметр-ф-ция, второй- сколько ждем).
setTimeout(func, 0). Вопрос на собеседовании. По сути это синхронная операция. Но вообще:
call stack -> Web Apis -> Callback Queue -> call stack

event loop. Асинхронность в js.
Есть call stack. При вызове setTimeout функция попадает сначала в call stack, потом в webApi, 
там ждёт например 10с, потом в CAllback queue, потом в call stack.
более сложный пример. Есть кнопка. Она сначала регистрируется в callstack -> webApi. Когда мы на нее нажимаем, 
она помещается в callback queue а потом в callstack.
Event loop пробегается по очереди callback queue и помещает элементы обратно в стек.

console.log('Start');
 setTimeout(function(){
     console.log('Inside timout')
 },0);
console.log('Start2');
// start1 start2 inside timeout. Т.к. через event loop settimeout проходит.

js работает в 1 потоке, т.к. находимся в браузере. Но позволяет делать что-то асинхронно.

Promise.
Определенная обертка над асинхронностью, которая позволяет работать с асинхронностью.
Не создавать callback внутри callback.
Есть задача. Получить 3 запроса с сервера. Или например в setTimout еще 1 seTimeout. Большая вложенность.
Код поддерживать сложно. Для решения этой проблемы есть Promise.
const p = new Promise(resolve, reject);
resolve - вызывается когда закончена успешно всинхронная операция.
reject - ыозвращает объект Promise, который был отклонен по указанной причине.
методы promise:
catch() - выводит ошибку, например 405.
finally - данный метод будет вызван в любом случае, даже если была ошибка.
Promise.all([sleep(2000),sleep(3000)] - вызывать 2 промиса.
.then(() => {
console.log('All promises')
})

Promise.race - когда выполнится первый промисе, он сразу отработает.

Замыкания - функция внутри функции. Одно значение сохранятеся(первый параметр), а другое можем менять, как пример.
functiont create(n){
	return function(num){
		console.log(1000*n + num)
	}
}
create(42);// ничего не получим.
const calc = create(42);
calc(1);//42001
// т.е. можем получить доступ до skope, верхней функции.

DOM(document object model). То что видим на странице - это html. Браузер парсит html и отображает.
JS имеет воможность взаимодействовать с DOM деревом. Каждый html тег является объектом.
DOM нужен чтобы из js достучаться до html, css.
DomContentLoaded. Когда весь html полностью загружен и пройден парсером, не дожидаясь загрузки изображений,
таблицы стилей.

Семантика- a ? b :c - означает, что если а верно, то выбираем b, иначе с .

Rest vs Spread ES6 синтаксис.
Spread - берет и разворачиват массив, с которым работаем. Spread оператор обозчается через ... . Spread позволяет работать с объектами и массивами.
Rest- такой же синтаксис как у оператора spread. Различие только в области вилимости. Rest можно испольщзовать для передачи массива в функцию. 
Rest берет элементы только те, которые не используются.
Пример Spread: 
const citiesOne = [ 'Mosckow', 'Kazan', 'Minsk' ]
const citiesTwo = [ 'Brest', 'Vitebsk', 'Gomel' ]
console.log(citiestOne);// [ 'Mosckow', 'Kazan', 'Minsk' ]
console.log(...citiesOne);// Mosckow, Kazan, Minsk - т.е. получаем набор строк.
// раньше испольщовали метод concat для объединения массивов.
const allCities = [...citiesOne, 'Washinton', citiesTwo]; // Клонимаруем массив. 

const someObject = {
Mosow: 20,
Misk: 2,
Kazan: 5,
Gomel: 1,
}
console.log(...someObject);// ошибка
console.log({...someObject});// а так можно. Склонировали объект, создали новый.
// Можно объеденить 2 объекта. Будет общий объект, состоящий из 2-х объектов. При этом происходит умный merge(т.е. если в 2-х объектах одинаковый ключ, то в результирующем объекте окажется ключ последнего добавленного объекта). 
const numbers = [1,2,42,17];
Math.max(1,2,42,17);//42
Math.max(numbers);// ошибка
Math.max(...numbers);// работает, 42. Тут надо испольщовать spred.

Крутой пример суммирования чисел, использую rest: 
function sum(int a, ...rest){
	return a + rest.reduce({accumulator, iterator) => accumulator + iterator, 0);
}
const numbers = [1,2,42,17];
sum(...numbers); // 62





















