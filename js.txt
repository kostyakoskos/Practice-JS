reduce - когда есть массив целых чисел, которые надо сложить.
const euros = [29.76, 41.85, 46.5];
const sum = euros.reduce((total, amount) => total + amount); 
sum // 118.11

Чила и логические величины являются элементарными типами данных.
Функции и объекты представляют собой ссылочный тип данных. Массивы, коллекции это объекты - ссылочный
тип данных.

Есть for и foreach в js.

{
//this is scope
}

Переменная let доступна только внутри {}.

Hoisting - можно обращаться к функции до того как ее опрделили. Или к переменной типа let можно обращаться до её
объявления. const - надо сначала объявить а потом исопльзовать.
В переменную можно присвоить функцию. 

Внутри функции можно писать ещё 1 функцию.

Методы массива
indexOf - номер элемента в массиве.
findIndex - когда работаем с объектами. Индекс объекта. Когда 2 и более объекта.
find - находит нудный объект сразу.
includes - проверять наличие какого-либо элемента.
map - принимает в себя функуцию. Внутри пишем стрелочную функцию. Можем сделать toUpperCase, 
в ^2 возвести. Создаем новый массив, можем занести в новую переменную. Служит для преобразования текущего массива в ноый массив.
filter - отфильтровать по полю например.
reduce - позволяет объединять все значеня массива в 1 значение. reduce(function, от куда начинаем суммировать(обычно с 0))
contains - спрашивает содержится ли такакя подстрока в строке.
concat- копируем массив по значению, не по ссылке.

for(let key in person) - аналог foreach. Он бежит не только по ключам самого объекта, он также может
заходить в его прототип.
Прототип- для того чтобы моно было расширять объект, например добавлять св-ва.
Класс object в js является самым главнм классом и все от него идет.

[] == [] true
[] === [] false, т.к. массив это ссылочный тип, и ссылки на пусты массивы будут разными

var всегда надо объявлять заранее. let можно объявлять при использовании.

{
let bar = 2;
var _bar = 4;
}
console.log(bar); undefined, т.к. вне области вилимости!
console.log(_bar); объявили как var, поэтому можем видеть за пределами скобок{}. Но если объявим в 
функции, то область видимости var только функция.

settimeout - есть в браузере. Пришла в js из браузерного api.
setTimeout(первый парметр-ф-ция, второй- сколько ждем).
setTimeout(func, 0). Вопрос на собеседовании. По сути это синхронная операция. Но вообще:
call stack -> Web Apis -> Callback Queue -> call stack

event loop. Асинхронность в js.
Есть call stack. При вызове setTimeout функция попадает сначала в call stack, потом в webApi, 
там ждкт например 10с, потом в CAllback queue, потом в call stack.
более сложный пример. Есть кнопка. Она сначала регичтрируется в callstack -> webApi. Когда мы на нее нажимаем, 
она помещается в callback queue а потом в callstack.
Event loop пробегается по очереди callback queue и помещает элементы обратно в стек.

console.log('Start');
 setTimeout(function(){
     console.log('Inside timout')
 },0);
console.log('Start2');
// start1 start2 inside timeout. Т.к. через event loop settimeout проходит.

js работает в 1 потоке, т.к. находимся в браузере. Но позволяет делать что-то асинхронно.

Promise.
Определенная обертка над асинхронностью, которая позволяет работать с исинхронностью.
Не создавать callback внутри callback.
Есть задача. Получить 3 запроса с сервера. Или например в setTimout еще 1 srTimeout. Большая вложенность.
Код поддерживать сложно. Для решения этой проблемы есть Promise.
const p = new Promise(resolve, reject);
resolve - вызывается когда закончена успешно всинхронная операция.
reject - 
методы promise:
catch() - выводит ошибку, например 405.
finally - данный метод будет вызван в любом случае, даже если была ошибка.
Promise.all([sleep(2000),sleep(3000)] - вызывать 2 промиса.
.then(() => {
console.log('All promises')
})

Promise.race - когда выполнится первый промисе, он сразу отработает.

Замыкания - функция внутри функции. Одно значение сохранятеся(первый параметр), а другое можем менять, как пример.

DOM(document object model). То что видим на странице - это html. Браузер парсит html и отображает.
JS имеет воможность взаимодействовать с DOM деревом. Каждый html тег является объектом.
DOM нужен чтобы из js достучаться до html, css
DomContentLoaded. Когда весь html полностью загружен и пройден парсером, не дожидаясь загрузки изображений,
таблицы стилей.

Семантика- это


